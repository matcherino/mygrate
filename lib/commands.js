// Generated by CoffeeScript 1.7.1
(function() {
  var Commands, DEFAULT_MINHOOK_DATE, Fs, Os, Path, ProjTemplate, Table, Utils, Wrench, async, cwd, dbInterface, down, errHandler, forceDown, getConfig, getDefaultUser, getEnv, getEnvConfig, getSubDirs, initMigrationsDir, migrationFile, pad2, ps, readMigrationFile, str, timestamp, username, writeConfig, _;

  Fs = require("fs");

  Path = require("path");

  async = require("async");

  Utils = require("./utils");

  Table = require("cli-table");

  Os = require("os");

  _ = require("lodash");

  Wrench = require("wrench");

  str = require('underscore.string');

  ProjTemplate = require('uber-ngen');

  username = require('username');

  ps = require('./parseSprocs');

  cwd = process.cwd();

  DEFAULT_MINHOOK_DATE = "999999999999";

  errHandler = function(err) {
    if (err) {
      console.error(err);
      return process.exit(1);
    } else {
      console.log("OK");
      return process.exit(0);
    }
  };

  getDefaultUser = function(vendor) {
    var platform, user;
    switch (vendor) {
      case 'mysql':
        user = 'root';
        break;
      case 'mssql':
        user = 'sa';
        break;
      default:
        platform = Os.platform();
        if (platform.match(/^darwin/)) {
          user = process.env.USER;
        } else {
          user = 'postgres';
        }
    }
    return user;
  };

  getEnv = function() {
    var env;
    return env = process.env.NODE_ENV || "development";
  };

  getEnvConfig = function() {
    return getConfig()[getEnv()];
  };

  getConfig = function() {
    var jsFile, jsonFile;
    jsFile = Path.join(Commands.migrationsDir, "config.js");
    jsonFile = Path.join(Commands.migrationsDir, "config.json");
    if (Fs.existsSync(jsFile)) {
      return require(jsFile);
    } else if (Fs.existsSync(jsonFile)) {
      return require(jsonFile);
    } else {
      console.error("Config file migrations/config.{js,json} NOT FOUND");
      return process.exit(1);
    }
  };

  writeConfig = function(config) {
    return Fs.writeFileSync(Path.join(Commands.migrationsDir, "config.json"), JSON.stringify(config, null, '  '));
  };

  dbInterface = function() {
    var Adapter, adapter, config, v, _ref, _ref1;
    if (!Fs.existsSync(Commands.migrationsDir)) {
      console.error("" + Commands.migrationsBasename + " directory not found");
      process.exit(1);
    }
    config = getEnvConfig();
    for (adapter in config) {
      v = config[adapter];
      if (adapter === "mygrate") {
        continue;
      }
      Adapter = require("./" + adapter);
      break;
    }
    return {
      config: config[adapter],
      minHookDate: (_ref = (_ref1 = config.mygrate) != null ? _ref1.minHookDate : void 0) != null ? _ref : DEFAULT_MINHOOK_DATE,
      schema: new Adapter(config[adapter]),
      vendor: adapter
    };
  };

  pad2 = function(num) {
    if (num < 10) {
      return "0" + num;
    } else {
      return num;
    }
  };

  timestamp = function(date, separator) {
    if (date == null) {
      date = new Date();
    }
    if (separator == null) {
      separator = "";
    }
    return [date.getUTCFullYear(), pad2(date.getUTCMonth() + 1), pad2(date.getUTCDate()), pad2(date.getUTCHours()), pad2(date.getUTCMinutes())].join(separator);
  };

  initMigrationsDir = function(vendor, config) {
    if (!Fs.existsSync(Commands.migrationsDir)) {
      Fs.mkdirSync(Commands.migrationsDir);
    }
    if (!Fs.existsSync(Commands.migrationsDir + "/config.json")) {
      writeConfig(config);
      return console.log("Created " + vendor + " sample configuration. Edit " + Commands.migrationsBasename + "/config.json.");
    }
  };

  getSubDirs = function(dirname, cb) {
    var dirs, file, stat, _i, _len, _ref;
    dirname = Path.resolve(dirname);
    dirs = [];
    _ref = Fs.readdirSync(dirname);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (!file.match(/^\d{12}/)) {
        continue;
      }
      stat = Fs.statSync(dirname + "/" + file);
      if (stat.isDirectory()) {
        if (stat.isDirectory()) {
          dirs.push(file);
        }
      }
    }
    return cb(null, dirs.sort());
  };

  migrationFile = function(version, which) {
    return Path.resolve(Commands.migrationsDir + "/" + version + "/" + which + ".sql");
  };

  readMigrationFile = function(migration, which) {
    var filename;
    filename = migrationFile(migration, which);
    if (Fs.existsSync(filename)) {
      return Fs.readFileSync(filename, "utf8");
    } else {
      return "";
    }
  };

  down = function(schema, migrations, cb) {
    var migrate;
    migrate = function(version, cb) {
      var filename, pre;
      filename = migrationFile(version, "down");
      pre = "Down " + Commands.migrationsBasename + "/" + version;
      return schema.execFile(filename, function(err) {
        if (err) {
          return cb("" + pre + "\n" + err);
        }
        return schema.remove(version, function(err) {
          if (err) {
            return cb("" + pre + "\n" + err);
          }
          console.log("" + pre);
          return cb(null);
        });
      });
    };
    return async.forEachSeries(migrations, migrate, cb);
  };

  forceDown = function(schema, version, cb) {
    var filename;
    filename = migrationFile(version, "down");
    return schema.execFile(filename, cb);
  };

  Commands = {
    migrationsDir: null,
    migrationsBasename: null,
    setMigrationsDir: function(dirname) {
      Commands.migrationsDir = Path.resolve(dirname);
      return Commands.migrationsBasename = Path.basename(Commands.migrationsDir);
    },
    "console": function() {
      var schema;
      schema = dbInterface().schema;
      return schema.console();
    },
    generate: (function(_this) {
      return function(argv, vendor) {
        var config, filename, path, suffix, template, ts;
        suffix = argv._[1];
        template = argv.template || "default";
        if (!vendor) {
          vendor = dbInterface().vendor;
        }
        if (!Fs.existsSync(Path.resolve(Commands.migrationsBasename))) {
          console.error("ERROR " + Commands.migrationBasename + " directory not found. Try `mygrate init`");
          process.exit(1);
        }
        if (typeof suffix !== "string") {
          console.error("Migration identifier missing");
          process.exit(1);
        }
        ts = timestamp();
        filename = ts;
        if (typeof suffix === "string") {
          filename += "-" + suffix;
        }
        path = Commands.migrationsDir + "/" + filename;
        if (!Fs.existsSync(path)) {
          Wrench.copyDirSyncRecursive(Path.resolve(__dirname, "../templates/" + vendor + "/content/" + template), Path.resolve(path));
          if (template !== 'default') {
            config = getConfig();
            if (config.development.mygrate.minHookDate === DEFAULT_MINHOOK_DATE) {
              config.development.mygrate.minHookDate = ts;
              writeConfig(config);
            }
          }
          return console.log("Migration created: " + path);
        }
      };
    })(this),
    init: (function(_this) {
      return function(argv) {
        var name, t, vendor;
        vendor = argv._[1];
        if (['mysql', 'postgresql', 'mssql'].indexOf(vendor) < 0) {
          vendor = "postgresql";
        }
        name = Path.basename(process.cwd()).replace(/\W/g, "_");
        if (Fs.existsSync(Commands.migrationsDir)) {
          console.error('Migrations directory exists.');
          return;
        }
        t = new ProjTemplate(vendor, {
          templates: Path.join(__dirname, '../templates'),
          name: name
        });
        return t.init(Commands.migrationsDir, function(err) {
          if (err) {
            throw err;
          }
          argv._ = ["new", "init"];
          return Commands.generate(argv, vendor);
        });
      };
    })(this),
    migrateUp: (function(_this) {
      return function(argv, cb) {
        var config, dirs, lastMigration, migrationsInDb, minHookDate, relMigrationsDir, schema, _ref;
        _ref = dbInterface(), schema = _ref.schema, config = _ref.config, minHookDate = _ref.minHookDate;
        dirs = null;
        lastMigration = null;
        migrationsInDb = null;
        relMigrationsDir = "./" + Path.relative(process.cwd(), Commands.migrationsDir);
        return async.series({
          ensureSchema: function(cb) {
            return schema.init(cb);
          },
          getMigrationDirs: function(cb) {
            return getSubDirs(Commands.migrationsDir, function(err, subdirs) {
              if (err) {
                return cb(err);
              }
              dirs = subdirs.sort();
              return cb(null);
            });
          },
          getAllMigrations: function(cb) {
            return schema.all(function(err, migrations) {
              migrationsInDb = migrations;
              return cb(err);
            });
          },
          getLastMigration: function(cb) {
            return schema.last(function(err, migration) {
              lastMigration = migration;
              return cb(err);
            });
          },
          validateMigrations: function(cb) {
            var d, last, m, missing, _i, _j, _len, _len1;
            if (lastMigration != null) {
              missing = false;
              last = lastMigration.version;
              console.log("DBG:dirs", dirs);
              for (_i = 0, _len = migrationsInDb.length; _i < _len; _i++) {
                m = migrationsInDb[_i];
                if (dirs.indexOf(m.version) < 0) {
                  console.error("ERROR '" + m.version + "' was migrated in DB but does not exist locally.\n./" + (Path.relative(process.cwd(), Commands.migrationsDir)) + " dir might be out of sync.");
                  missing = 1;
                }
              }
              for (_j = 0, _len1 = dirs.length; _j < _len1; _j++) {
                d = dirs[_j];
                if (d < last && !_.find(migrationsInDb, function(m) {
                  return m.version === d;
                })) {
                  console.error("ERROR " + relMigrationsDir + "/" + d + " will be skipped since it is older than the\nlast migration '" + last + "' in database. Rename the dir if it needs to be migrated.");
                  missing = true;
                }
              }
              if (missing) {
                process.exit(1);
              }
            }
            return cb(null);
          },
          run: function(cb) {
            var index, migrateUp, msg, versions;
            if (lastMigration != null ? lastMigration.version : void 0) {
              index = dirs.indexOf(lastMigration.version);
              versions = dirs.slice(index + 1);
            } else {
              versions = dirs;
            }
            if (versions.length > 0) {
              migrateUp = function(version, cb) {
                return async.series({
                  notx: function(cb) {
                    var filename;
                    filename = migrationFile(version, "notx");
                    if (!Fs.existsSync(filename)) {
                      return cb();
                    }
                    return schema.execFile(filename, {
                      notx: true
                    }, function(err) {
                      if (err) {
                        return cb(err);
                      }
                      console.log("NoTx " + Commands.migrationsBasename + "/" + version);
                      return cb();
                    });
                  },
                  upscript: function(cb) {
                    var filename;
                    filename = migrationFile(version, "up");
                    return schema.execFile(filename, function(err) {
                      var up;
                      if (err) {
                        return cb("Up " + Commands.migrationsBasename + "/" + version + ": exit code " + err);
                      }
                      up = readMigrationFile(version, "up");
                      down = readMigrationFile(version, "down");
                      return schema.add(version, up, down, function(err) {
                        if (err) {
                          return cb(err);
                        }
                        console.log("Up " + Commands.migrationsBasename + "/" + version);
                        return cb(null);
                      });
                    });
                  }
                }, cb);
              };
              return async.forEachSeries(versions, migrateUp, cb);
            } else {
              msg = "Nothing to run.";
              if (lastMigration != null ? lastMigration.version : void 0) {
                msg += (" Last migration: " + Commands.migrationsBasename + "/") + lastMigration.version;
              }
              console.log(msg);
              return cb(null);
            }
          },
          registerSprocs: function(cb) {
            var sprocsDir;
            sprocsDir = Path.join(Commands.migrationsDir, "sprocs", "*.sql");
            return ps.parseDirPattern(sprocsDir, function(err, sprocs) {
              if (err) {
                return cb(err);
              }
              if (sprocs.length === 0) {
                return cb();
              }
              return async.eachSeries(sprocs, schema.registerSproc.bind(schema), cb);
            });
          }
        }, function(err) {
          if (err) {
            console.error(err);
            return process.exit(1);
          } else {
            console.log("OK");
            return process.exit(0);
          }
        });
      };
    })(this),
    migrateDown: (function(_this) {
      return function(argv, cb) {
        var countOrVersion, dirs, lastMigration, schema, _ref;
        schema = dbInterface().schema;
        countOrVersion = (_ref = argv._[1]) != null ? _ref : 1;
        dirs = null;
        lastMigration = null;
        return async.series({
          getLastMigration: function(cb) {
            return schema.last(function(err, migration) {
              if (err) {
                return cb(err);
              }
              lastMigration = migration;
              return cb(err);
            });
          },
          getMigrationDirs: function(cb) {
            return getSubDirs(Commands.migrationsDir, function(err, subdirs) {
              if (err) {
                return cb(err);
              }
              dirs = subdirs;
              return cb(null);
            });
          },
          run: function(cb) {
            return schema.all(function(err, migrations) {
              var count, found, migration, version, versions, _i, _j, _k, _len, _len1, _len2;
              if (err) {
                return cb(err);
              }
              if (migrations.length === 0) {
                console.log("0 migrations found");
                return cb(null);
              }
              versions = [];
              if (countOrVersion === "all") {
                for (_i = 0, _len = migrations.length; _i < _len; _i++) {
                  migration = migrations[_i];
                  versions.push(migration.version);
                }
                return down(schema, versions, cb);
              } else if (_.isNumber(countOrVersion)) {
                count = countOrVersion;
                for (_j = 0, _len1 = migrations.length; _j < _len1; _j++) {
                  migration = migrations[_j];
                  versions.push(migration.version);
                  count -= 1;
                  if (count === 0) {
                    break;
                  }
                }
                return down(schema, versions, cb);
              } else {
                version = countOrVersion;
                versions = [];
                for (_k = 0, _len2 = migrations.length; _k < _len2; _k++) {
                  migration = migrations[_k];
                  versions.push(migration.version);
                  if (migration.version === version) {
                    found = migration;
                    break;
                  }
                }
                if (found) {
                  return down(schema, versions, cb);
                } else {
                  return cb(null);
                }
              }
            });
          }
        }, function(err) {
          if (cb != null) {
            return cb(err);
          }
          if (err) {
            console.error(err);
            return process.exit(1);
          } else {
            console.log("OK");
            return process.exit(0);
          }
        });
      };
    })(this),
    migrateLast: function() {
      var dirs, lastMigration, schema;
      schema = dbInterface().schema;
      dirs = null;
      lastMigration = null;
      return async.series({
        getLastMigration: function(cb) {
          return schema.last(function(err, migration) {
            if (err) {
              return cb(err);
            }
            lastMigration = migration;
            return cb(err);
          });
        },
        getMigrationDirs: function(cb) {
          return getSubDirs("migrations", function(err, subdirs) {
            if (err) {
              return cb(err);
            }
            dirs = subdirs;
            return cb(null);
          });
        },
        run: function(cb) {
          return async.series({
            migrateDownIfLast: function(cb) {
              if (lastMigration.version === _.last(dirs)) {
                return Commands.migrateDown({
                  _: ["down", 1]
                }, function(err) {
                  if (err) {
                    return cb(err);
                  }
                  console.log("OK1\n");
                  return cb();
                });
              } else {
                return cb();
              }
            },
            migrateUp: function(cb) {
              return Commands.migrateUp({
                _: ["up"]
              }, cb);
            }
          }, cb);
        }
      }, function(err) {
        if (err) {
          console.error(err);
          return process.exit(1);
        } else {
          console.log("OK2");
          return process.exit(0);
        }
      });
    },
    printConfig: function(config) {
      var s;
      s = "Connection: ";
      s += config.user;
      s += "@" + (config.host || config.server);
      if (config.port) {
        s += ":" + config.port;
      }
      if (config.database) {
        s += "/" + config.database;
      }
      return console.log(s);
    },
    history: (function(_this) {
      return function() {
        var config, schema, _ref;
        _ref = dbInterface(), config = _ref.config, schema = _ref.schema;
        return schema.all(function(err, migrations) {
          var at, migration, table, _i, _len;
          if (err) {
            console.error(err);
            process.exit(1);
          }
          Commands.printConfig(config);
          if (migrations.length < 1) {
            console.log("0 migrations found");
          } else {
            table = new Table({
              head: ["migrated at", "script set"],
              chars: {
                'top': '',
                'top-mid': '',
                'top-left': '',
                'top-right': '',
                'bottom': '',
                'bottom-mid': '',
                'bottom-left': '',
                'bottom-right': '',
                'left': '',
                'left-mid': '',
                'mid': '',
                'mid-mid': '',
                'right': '',
                'right-mid': '',
                'middle': ' '
              }
            });
            for (_i = 0, _len = migrations.length; _i < _len; _i++) {
              migration = migrations[_i];
              at = timestamp(new Date(migration.created_at), "-");
              table.push([at, migration.version]);
            }
            console.log("");
            console.log(table.toString());
          }
          return process.exit(0);
        });
      };
    })(this),
    dropDatabase: function(argv) {
      var schema, vendor, _ref;
      if (argv.me) {
        argv.user = username.sync();
      }
      _ref = dbInterface(), schema = _ref.schema, vendor = _ref.vendor;
      return schema.dropDatabase(getDefaultUser(vendor), argv);
    },
    createDatabase: function(argv) {
      var schema, vendor, _ref;
      if (argv.me) {
        argv.user = username.sync();
      }
      _ref = dbInterface(), schema = _ref.schema, vendor = _ref.vendor;
      return schema.createDatabase(getDefaultUser(vendor), argv);
    },
    execSql: function(argv) {
      var db, sql;
      sql = argv._[1];
      if (!((sql != null ? sql.trim().length : void 0) > 0)) {
        throw new Error('Empty SQL expression');
      }
      db = dbInterface().schema;
      return db.exec(sql, function(err, result) {
        if (err) {
          throw new Error(err);
        } else {
          if (result) {
            console.log(JSON.stringify(result, null, 2));
          } else {
            console.log("Empty result");
          }
          return process.exit(0);
        }
      });
    },
    execFile: function(argv) {
      var filename, schema;
      filename = argv._[1];
      if (typeof filename !== 'string') {
        return errHandler('Filename required');
      }
      filename = Path.resolve(filename);
      schema = dbInterface().schema;
      return schema.execFile(filename, errHandler);
    },
    ping: function(argv) {
      var db, sql;
      sql = "select 1;";
      db = dbInterface().schema;
      return db.exec(sql, function(err, result) {
        if (err) {
          return process.exit(1);
        } else {
          return process.exit(0);
        }
      });
    }
  };

  module.exports = Commands;

}).call(this);
