// Generated by CoffeeScript 1.6.3
(function() {
  var Commands, DEFAULT_MINHOOK_DATE, Fs, Os, Path, Table, Utils, Wrench, async, cwd, dbInterface, down, errHandler, forceDown, getConfig, getDefaultUser, getEnv, getEnvConfig, getSubDirs, initMigrationsDir, migrationFile, pad2, readMigrationFile, timestamp, writeConfig, _,
    _this = this;

  Fs = require("fs");

  Path = require("path");

  async = require("async");

  Utils = require("./utils");

  Table = require("cli-table");

  Os = require("os");

  _ = require("underscore");

  Wrench = require("wrench");

  cwd = process.cwd();

  DEFAULT_MINHOOK_DATE = "999999999999";

  errHandler = function(err) {
    if (err) {
      console.error(err);
      return process.exit(1);
    } else {
      console.log("OK");
      return process.exit(0);
    }
  };

  getDefaultUser = function(vendor) {
    var platform, user;
    if (vendor === 'mysql') {
      user = 'root';
    } else {
      platform = Os.platform();
      if (platform.match(/^darwin/)) {
        user = process.env.USER;
      } else {
        user = 'postgres';
      }
    }
    return user;
  };

  getEnv = function() {
    var env;
    return env = process.env.NODE_ENV || "development";
  };

  getEnvConfig = function() {
    return getConfig()[getEnv()];
  };

  getConfig = function() {
    var oldConfig;
    try {
      return require(process.cwd() + "/migrations/config.json");
    } catch (_error) {
      if (Fs.existsSync(process.cwd() + "/migrations/config.js")) {
        oldConfig = require(process.cwd() + "/migrations/config");
        writeConfig(oldConfig);
        console.error("migrations/config.js has been converted to migrations/config.json.\nDelete migrations/config.js at your convenience.");
      } else {
        console.error("Config file migration/config.json NOT FOUND");
      }
      return process.exit(1);
    }
  };

  writeConfig = function(config) {
    return Fs.writeFileSync(process.cwd() + "/migrations/config.json", JSON.stringify(config, null, '  '));
  };

  dbInterface = function() {
    var Adapter, adapter, config, v, _ref, _ref1;
    if (!Fs.existsSync("migrations")) {
      console.error("migrations directory not found");
      process.exit(1);
    }
    config = getEnvConfig();
    for (adapter in config) {
      v = config[adapter];
      if (adapter === "mygrate") {
        continue;
      }
      Adapter = require("./" + adapter);
      break;
    }
    return {
      config: config[adapter],
      minHookDate: (_ref = (_ref1 = config.mygrate) != null ? _ref1.minHookDate : void 0) != null ? _ref : DEFAULT_MINHOOK_DATE,
      schema: new Adapter(config[adapter]),
      vendor: adapter
    };
  };

  pad2 = function(num) {
    if (num < 10) {
      return "0" + num;
    } else {
      return num;
    }
  };

  timestamp = function(date, separator) {
    if (date == null) {
      date = new Date();
    }
    if (separator == null) {
      separator = "";
    }
    return [date.getUTCFullYear(), pad2(date.getUTCMonth() + 1), pad2(date.getUTCDate()), pad2(date.getUTCHours()), pad2(date.getUTCMinutes())].join(separator);
  };

  initMigrationsDir = function(vendor, config) {
    if (!Fs.existsSync("./migrations")) {
      Fs.mkdirSync("./migrations");
    }
    if (!Fs.existsSync("./migrations/config.json")) {
      writeConfig(config);
      return console.log("Created " + vendor + " sample configuration. Edit migrations/config.json.");
    }
  };

  getSubDirs = function(dirname, cb) {
    var dirs, file, stat, _i, _len, _ref;
    dirname = Path.resolve(dirname);
    dirs = [];
    _ref = Fs.readdirSync(dirname);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (!file.match(/^\d{12}/)) {
        continue;
      }
      stat = Fs.statSync(dirname + "/" + file);
      if (stat.isDirectory()) {
        if (stat.isDirectory()) {
          dirs.push(file);
        }
      }
    }
    return cb(null, dirs.sort());
  };

  migrationFile = function(version, which) {
    return Path.resolve("migrations/" + version + "/" + which + ".sql");
  };

  readMigrationFile = function(migration, which) {
    var filename;
    filename = migrationFile(migration, which);
    if (Fs.existsSync(filename)) {
      return Fs.readFileSync(filename, "utf8");
    } else {
      return "";
    }
  };

  down = function(schema, migrations, cb) {
    var migrate;
    migrate = function(version, cb) {
      var filename;
      filename = migrationFile(version, "down");
      return schema.execFile(filename, function(err) {
        if (err) {
          return cb("Down migrations/" + version + ": " + err);
        }
        return schema.remove(version, function(err) {
          if (err) {
            return cb("Down migrations/" + version + ": " + err);
          }
          console.log("Down migrations/" + version);
          return cb(null);
        });
      });
    };
    return async.forEachSeries(migrations, migrate, cb);
  };

  forceDown = function(schema, version, cb) {
    var filename;
    filename = migrationFile(version, "down");
    return schema.execFile(filename, cb);
  };

  Commands = {
    "console": function() {
      var schema;
      schema = dbInterface().schema;
      return schema.console();
    },
    generate: function(argv, vendor) {
      var config, filename, path, suffix, template, ts;
      suffix = argv._[1];
      template = argv.template || "default";
      if (!vendor) {
        vendor = dbInterface().vendor;
      }
      if (!Fs.existsSync(Path.resolve("migrations"))) {
        console.error("ERROR migrations directory not found. Try `mygrate init`");
        process.exit(1);
      }
      if (typeof suffix !== "string") {
        console.error("Migration identifier missing");
        process.exit(1);
      }
      ts = timestamp();
      filename = ts;
      if (typeof suffix === "string") {
        filename += "-" + suffix;
      }
      path = "./migrations/" + filename;
      if (!Fs.existsSync(path)) {
        Wrench.copyDirSyncRecursive(Path.resolve(__dirname, "../src/templates/" + vendor + "/" + template), Path.resolve(path));
        if (template !== 'default') {
          config = getConfig();
          if (config.development.mygrate.minHookDate === DEFAULT_MINHOOK_DATE) {
            config.development.mygrate.minHookDate = ts;
            writeConfig(config);
          }
        }
        return console.log("Migration created: " + path);
      }
    },
    init: function(argv) {
      var config, name, vendor;
      vendor = argv._[1];
      if (['mysql', 'postgresql'].indexOf(vendor) < 0) {
        vendor = "postgresql";
      }
      name = Path.basename(process.cwd()).replace(/\W/g, "_");
      switch (vendor) {
        case 'mysql':
          config = {
            development: {
              mygrate: {
                minHookDate: DEFAULT_MINHOOK_DATE
              },
              mysql: {
                host: "localhost",
                database: "" + name + "_dev",
                user: "" + name + "_dev_user",
                password: "dev",
                port: 3306
              }
            },
            test: {
              mysql: {
                host: "localhost",
                database: "" + name + "_test",
                user: "" + name + "_test_user",
                password: "test",
                port: 3306
              }
            },
            production: {
              mysql: {
                host: "localhost",
                database: "" + name + "_prod",
                user: "" + name + "_prod_user",
                password: "prod",
                port: 3306
              }
            }
          };
          break;
        case 'postgres':
        case 'postgresql':
          config = {
            development: {
              mygrate: {
                minHookDate: DEFAULT_MINHOOK_DATE
              },
              postgresql: {
                host: "localhost",
                database: "" + name + "_dev",
                user: "" + name + "_dev_user",
                password: "dev"
              }
            },
            test: {
              postgresql: {
                host: "localhost",
                database: "" + name + "_test",
                user: "" + name + "_test_user",
                password: "test"
              }
            },
            production: {
              postgresql: {
                host: "localhost",
                database: "" + name + "_prod",
                user: "" + name + "_prod_user",
                password: "prod"
              }
            }
          };
      }
      initMigrationsDir(vendor, config);
      argv._ = ["new", "init"];
      return Commands.generate(argv, vendor);
    },
    migrateUp: function(argv, cb) {
      var config, dirs, lastMigration, minHookDate, schema, _ref;
      _ref = dbInterface(), schema = _ref.schema, config = _ref.config, minHookDate = _ref.minHookDate;
      dirs = null;
      lastMigration = null;
      return async.series({
        ensureSchema: function(cb) {
          return schema.init(cb);
        },
        getMigrationDirs: function(cb) {
          return getSubDirs("migrations", function(err, subdirs) {
            if (err) {
              return cb(err);
            }
            dirs = subdirs.sort();
            return cb(null);
          });
        },
        getLastMigration: function(cb) {
          return schema.last(function(err, migration) {
            lastMigration = migration;
            return cb(err);
          });
        },
        run: function(cb) {
          var index, migrateUp, msg, versions;
          if (lastMigration != null ? lastMigration.version : void 0) {
            index = dirs.indexOf(lastMigration.version);
            versions = dirs.slice(index + 1);
          } else {
            versions = dirs;
          }
          if (versions.length > 0) {
            migrateUp = function(version, cb) {
              return async.series({
                prehook: function(cb) {
                  var filename;
                  filename = Path.resolve("migrations/" + version + "/prehook");
                  if (Fs.existsSync(filename)) {
                    timestamp = version.slice(0, 12);
                    if (minHookDate.slice(0, 12) > timestamp) {
                      console.log("Skipping " + version + "/prehook");
                      return cb();
                    }
                    console.log("Running " + version + "/prehook");
                    return Utils.spawn(filename, [], {
                      cwd: Path.dirname(filename)
                    }, cb);
                  } else {
                    return cb();
                  }
                },
                upscript: function(cb) {
                  var filename;
                  filename = migrationFile(version, "up");
                  return schema.execFile(filename, function(err) {
                    var up;
                    if (err) {
                      return cb("Up migrations/" + version + ": exit code " + err);
                    }
                    up = readMigrationFile(version, "up");
                    down = readMigrationFile(version, "down");
                    return schema.add(version, up, down, function(err) {
                      if (err) {
                        return cb(err);
                      }
                      console.log("Up migrations/" + version);
                      return cb(null);
                    });
                  });
                }
              }, cb);
            };
            return async.forEachSeries(versions, migrateUp, cb);
          } else {
            msg = "Nothing to run.";
            if (lastMigration != null ? lastMigration.version : void 0) {
              msg += " Last recorded migration: migrations/" + lastMigration.version;
            }
            console.log(msg);
            return cb(null);
          }
        }
      }, function(err) {
        if (err) {
          console.error(err);
          return process.exit(1);
        } else {
          console.log("OK");
          return process.exit(0);
        }
      });
    },
    migrateDown: function(argv, cb) {
      var countOrVersion, dirs, lastMigration, schema, _ref;
      schema = dbInterface().schema;
      countOrVersion = (_ref = argv._[1]) != null ? _ref : 1;
      dirs = null;
      lastMigration = null;
      return async.series({
        getLastMigration: function(cb) {
          return schema.last(function(err, migration) {
            if (err) {
              return cb(err);
            }
            lastMigration = migration;
            return cb(err);
          });
        },
        getMigrationDirs: function(cb) {
          return getSubDirs("migrations", function(err, subdirs) {
            if (err) {
              return cb(err);
            }
            dirs = subdirs;
            return cb(null);
          });
        },
        run: function(cb) {
          return schema.all(function(err, migrations) {
            var count, found, migration, version, versions, _i, _j, _k, _len, _len1, _len2;
            if (err) {
              return cb(err);
            }
            if (migrations.length === 0) {
              console.log("0 migrations found");
              return cb(null);
            }
            versions = [];
            if (countOrVersion === "all") {
              for (_i = 0, _len = migrations.length; _i < _len; _i++) {
                migration = migrations[_i];
                versions.push(migration.version);
              }
              return down(schema, versions, cb);
            } else if (_.isNumber(countOrVersion)) {
              count = countOrVersion;
              for (_j = 0, _len1 = migrations.length; _j < _len1; _j++) {
                migration = migrations[_j];
                versions.push(migration.version);
                count -= 1;
                if (count === 0) {
                  break;
                }
              }
              return down(schema, versions, cb);
            } else {
              version = countOrVersion;
              versions = [];
              for (_k = 0, _len2 = migrations.length; _k < _len2; _k++) {
                migration = migrations[_k];
                versions.push(migration.version);
                if (migration.version === version) {
                  found = migration;
                  break;
                }
              }
              if (found) {
                return down(schema, versions, cb);
              } else {
                return cb(null);
              }
            }
          });
        }
      }, function(err) {
        if (cb != null) {
          return cb(err);
        }
        if (err) {
          console.error(err);
          return process.exit(1);
        } else {
          console.log("OK");
          return process.exit(0);
        }
      });
    },
    migrateLast: function() {
      var dirs, lastMigration, schema;
      schema = dbInterface().schema;
      dirs = null;
      lastMigration = null;
      return async.series({
        getLastMigration: function(cb) {
          return schema.last(function(err, migration) {
            if (err) {
              return cb(err);
            }
            lastMigration = migration;
            return cb(err);
          });
        },
        getMigrationDirs: function(cb) {
          return getSubDirs("migrations", function(err, subdirs) {
            if (err) {
              return cb(err);
            }
            dirs = subdirs;
            return cb(null);
          });
        },
        run: function(cb) {
          return async.series({
            migrateDownIfLast: function(cb) {
              if (lastMigration.version === _.last(dirs)) {
                return Commands.migrateDown({
                  _: ["down", 1]
                }, function(err) {
                  if (err) {
                    return cb(err);
                  }
                  console.log("OK1\n");
                  return cb();
                });
              } else {
                return cb();
              }
            },
            migrateUp: function(cb) {
              return Commands.migrateUp({
                _: ["up"]
              }, cb);
            }
          }, cb);
        }
      }, function(err) {
        if (err) {
          console.error(err);
          return process.exit(1);
        } else {
          console.log("OK2");
          return process.exit(0);
        }
      });
    },
    printConfig: function(config) {
      var s;
      s = "Connection: ";
      s += config.user;
      s += "@" + config.host;
      if (config.port) {
        s += ":" + config.port;
      }
      if (config.database) {
        s += "/" + config.database;
      }
      return console.log(s);
    },
    history: function() {
      var config, schema, _ref;
      _ref = dbInterface(), config = _ref.config, schema = _ref.schema;
      return schema.all(function(err, migrations) {
        var at, migration, table, _i, _len;
        if (err) {
          console.error(err);
          process.exit(1);
        }
        Commands.printConfig(config);
        if (migrations.length < 1) {
          console.log("0 migrations found");
        } else {
          table = new Table({
            head: ["migrated at", "script set"],
            chars: {
              'top': '',
              'top-mid': '',
              'top-left': '',
              'top-right': '',
              'bottom': '',
              'bottom-mid': '',
              'bottom-left': '',
              'bottom-right': '',
              'left': '',
              'left-mid': '',
              'mid': '',
              'mid-mid': '',
              'right': '',
              'right-mid': '',
              'middle': ' '
            }
          });
          for (_i = 0, _len = migrations.length; _i < _len; _i++) {
            migration = migrations[_i];
            at = timestamp(new Date(migration.created_at), "-");
            table.push([at, migration.version]);
          }
          console.log("");
          console.log(table.toString());
        }
        return process.exit(0);
      });
    },
    dropDatabase: function() {
      var schema, vendor, _ref;
      _ref = dbInterface(), schema = _ref.schema, vendor = _ref.vendor;
      return schema.dropDatabase(getDefaultUser(vendor));
    },
    createDatabase: function() {
      var schema, vendor, _ref;
      _ref = dbInterface(), schema = _ref.schema, vendor = _ref.vendor;
      return schema.createDatabase(getDefaultUser(vendor));
    },
    execFile: function(argv) {
      var filename, schema;
      filename = argv._[1];
      if (typeof filename !== 'string') {
        return errHandler('Filename required');
      }
      filename = Path.resolve(filename);
      schema = dbInterface().schema;
      return schema.execFile(filename, errHandler);
    }
  };

  module.exports = Commands;

}).call(this);
