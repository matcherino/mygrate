// Generated by CoffeeScript 1.6.3
(function() {
  var Async, Fs, Path, Pg, Postgresql, Prompt, Transaction, Utils, errorToLineCol,
    __slice = [].slice;

  Path = require("path");

  Fs = require("fs");

  Utils = require("./utils");

  Async = require("async");

  Prompt = require("prompt");

  Prompt.message = '';

  Pg = require("pg.js");

  Transaction = require("./pg-transaction");

  /*
  # Finds the line, col based on error.position
  */


  errorToLineCol = function(sql, err) {
    var ch, column, i, line, max, message, position;
    message = err.message;
    position = err.position - 1;
    line = 1;
    column = 1;
    max = sql.length;
    i = 0;
    while (i < max && i < position) {
      ch = sql[i];
      if (ch === '\r') {
        line++;
        column = 1;
        if (i + 1 < max) {
          if (sql[i + 1] === '\n') {
            i++;
          }
        }
      } else if (ch === '\n') {
        line++;
        column = 1;
      } else {
        column++;
      }
      i++;
    }
    return {
      message: message,
      line: line,
      column: column
    };
  };

  Postgresql = (function() {
    function Postgresql(config) {
      this.config = config;
      if (this.config.host == null) {
        this.config.host = 'localhost';
      }
      if (this.config.port == null) {
        this.config.port = 5432;
      }
    }

    Postgresql.prototype.using = function(config, cb) {
      if (arguments.length === 1) {
        cb = config;
        config = this.config;
      }
      return Pg.connect(config, cb);
    };

    Postgresql.prototype.exec = function(sql, cb) {
      return this.using(function(err, client, release) {
        if (err) {
          return cb(err);
        }
        return client.query(sql, function(err, result) {
          release();
          return cb(err, result);
        });
      });
    };

    Postgresql.prototype.execFileCLI = function(filename, cb) {
      var args, command, host, port;
      port = this.config.port || 5432;
      host = this.config.host || "localhost";
      command = "psql";
      args = ["-U", this.config.user, "-q", "-d", this.config.database, "-h", host, "-p", port, "--file=" + filename, "-1", "--set", "ON_ERROR_STOP=1"];
      return Utils.spawn(command, args, {
        cwd: Path.dirname(filename),
        env_add: {
          PGPASSWORD: this.config.password
        }
      }, cb);
    };

    Postgresql.prototype.execFileDriver = function(filename, cb) {
      var err, script;
      try {
        script = Fs.readFileSync(filename, 'utf8');
      } catch (_error) {
        err = _error;
        return cb(err);
      }
      return this.using(function(err, client, release) {
        var tx;
        tx = new Transaction(client);
        tx.begin();
        tx.savepoint('mygrate');
        return client.query(script, function(err, result) {
          var info;
          release();
          if (err) {
            tx.rollback('mygrate');
            tx.release('mygrate');
            if (err.position) {
              info = errorToLineCol(script, err);
              console.error("" + (Path.basename(filename)) + " [" + info.line + ", " + info.column + "] " + info.message + "\n");
              return cb(1);
            } else {
              return cb(err);
            }
          }
          tx.release('mygrate');
          return tx.commit(cb);
        });
      });
    };

    Postgresql.prototype.console = function() {
      var args, command, host, port;
      port = this.config.port || 5432;
      host = this.config.host || "localhost";
      command = "psql";
      args = ["-U", this.config.user, "-d", this.config.database, "-h", host, "-p", port];
      return Utils.spawn(command, args, {
        stdio: 'inherit',
        env_add: {
          PGPASSWORD: this.config.password
        }
      }, function(code) {
        return process.exit(code);
      });
    };

    Postgresql.prototype.execFile = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.execFileDriver.apply(this, args);
    };

    Postgresql.prototype.init = function(cb) {
      var sql;
      sql = "create table if not exists schema_migrations (\n  version varchar(256) not null primary key,\n  up text,\n  down text,\n  created_at timestamp default current_timestamp\n);";
      return this.exec(sql, cb);
    };

    Postgresql.prototype.last = function(cb) {
      var sql;
      sql = "select *\nfrom schema_migrations\norder by version desc\nlimit 1;";
      return this.exec(sql, function(err, result) {
        if (err) {
          return cb(err);
        }
        return cb(null, result.rows[0]);
      });
    };

    Postgresql.prototype.all = function(cb) {
      var sql;
      sql = "select *\nfrom schema_migrations\norder by version desc;";
      return this.exec(sql, function(err, result) {
        var _ref;
        if ((err != null ? (_ref = err.message) != null ? _ref.indexOf('"schema_migrations" does not exist') : void 0 : void 0) > 0) {
          return cb(null, []);
        }
        if (err) {
          return cb(err);
        }
        return cb(null, result.rows);
      });
    };

    Postgresql.prototype.add = function(version, up, down, cb) {
      var sql;
      sql = "insert into schema_migrations(version, up, down)\nvalues($1, $2, $3)";
      return this.using(function(err, client, release) {
        return client.query(sql, [version, up, down], function() {
          release();
          return cb();
        });
      });
    };

    Postgresql.prototype.remove = function(version, cb) {
      var sql;
      sql = "delete from schema_migrations\nwhere version = $1";
      return this.using(function(err, client, release) {
        return client.query(sql, [version], function(err) {
          release();
          return cb(err);
        });
      });
    };

    Postgresql.prototype.createDatabase = function(defaultUser) {
      var config, prompts, self, using;
      Prompt.delimiter = "";
      Prompt.start();
      self = this;
      config = this.config;
      using = this.using;
      prompts = [
        {
          name: 'user',
          description: 'root user',
          "default": defaultUser
        }, {
          name: 'password',
          hidden: true
        }
      ];
      return Prompt.get(prompts, function(err, result) {
        var execRootSql, host, password, port, statements, user;
        user = result.user, password = result.password, host = result.host, port = result.port;
        if (password.trim().length === 0) {
          password = null;
        }
        statements = ["drop database if exists " + config.database + ";", "drop user if exists " + config.user + ";", "create user " + config.user + " password '" + config.password + "' SUPERUSER CREATEROLE;", "create database " + config.database + " owner " + config.user + ";"];
        execRootSql = function(sql, cb) {
          var rootConfig;
          rootConfig = {
            user: user,
            password: password,
            host: config.host,
            port: config.port,
            database: "postgres"
          };
          return using(rootConfig, function(err, client) {
            if (err) {
              console.error(err);
            }
            return client.query(sql, cb);
          });
        };
        return Async.forEachSeries(statements, execRootSql, function(err) {
          if (err) {
            console.error(err);
            console.error("Verify migrations/config.js has the correct host and port");
            return process.exit(1);
          } else {
            console.log("Created\n\tdatabase: " + config.database + "\n\tuser: " + config.user + "\n\tpassword: " + config.password + "\n\thost: " + config.host + "\n\tport: " + config.port);
            console.log("OK");
            return process.exit(0);
          }
        });
      });
    };

    Postgresql.prototype.dropDatabase = function(defaultUser) {
      var config, prompts, self, using;
      Prompt.delimiter = "";
      Prompt.start();
      self = this;
      config = this.config;
      using = this.using;
      prompts = [
        {
          name: 'user',
          description: 'root user',
          "default": defaultUser
        }, {
          name: 'password',
          hidden: true
        }
      ];
      return Prompt.get(prompts, function(err, result) {
        var execRootSql, host, password, port, statements, user;
        user = result.user, password = result.password, host = result.host, port = result.port;
        if (password.trim().length === 0) {
          password = null;
        }
        statements = ["drop database if exists " + config.database + ";", "drop user if exists " + config.user + ";"];
        execRootSql = function(sql, cb) {
          var rootConfig;
          rootConfig = {
            user: user,
            password: password,
            host: config.host,
            port: config.port,
            database: "postgres"
          };
          return using(rootConfig, function(err, client) {
            if (err) {
              console.error(err);
            }
            return client.query(sql, cb);
          });
        };
        return Async.forEachSeries(statements, execRootSql, function(err) {
          if (err) {
            console.error(err);
            return process.exit(1);
          } else {
            console.log("Dropped\n\tdatabase: " + config.database + "\n\tuser: " + config.user);
            console.log("OK");
            return process.exit(0);
          }
        });
      });
    };

    return Postgresql;

  })();

  module.exports = Postgresql;

}).call(this);
