// Generated by CoffeeScript 1.7.1
(function() {
  var Async, Fs, Path, Postgres, Postgresql, Prompt, SqlError, Utils, toSqlError,
    __slice = [].slice;

  Path = require("path");

  Fs = require("fs");

  Utils = require("./utils");

  Async = require("async");

  Prompt = require("prompt");

  Prompt.message = '';

  Postgres = require('dalicious/dalicious-postgres');

  SqlError = function(message, filename, line, column) {
    this.name = "SqlError";
    this.message = message;
    this.filename = filename;
    this.line = line;
    return this.column = column;
  };

  SqlError.prototype = new Error();

  SqlError.prototype.constructor = SqlError;


  /*
   * Finds the line, col based on error.position
   */

  toSqlError = function(filename, err, sql) {
    var ch, column, i, line, max, message, position;
    if (sql == null) {
      sql = "";
    }
    if (err.position == null) {
      return err.message;
    }
    if (!sql) {
      try {
        sql = Fs.readFileSync(filename, 'utf8');
      } catch (_error) {
        err = _error;
        return err;
      }
    }
    message = err.message;
    position = err.position - 1;
    line = 1;
    column = 1;
    max = sql.length;
    i = 0;
    while (i < max && i < position) {
      ch = sql[i];
      if (ch === '\r') {
        line++;
        column = 1;
        if (i + 1 < max) {
          if (sql[i + 1] === '\n') {
            i++;
          }
        }
      } else if (ch === '\n') {
        line++;
        column = 1;
      } else {
        column++;
      }
      i++;
    }
    return new SqlError(message, filename, line, column);
  };

  Postgresql = (function() {
    function Postgresql(config) {
      this.config = config;
      if (this.config.host == null) {
        this.config.host = 'localhost';
      }
      if (this.config.port == null) {
        this.config.port = 5432;
      }
      this.UserDb = Postgres.define(this.config);
    }

    Postgresql.prototype.exec = function(cmd, cb) {
      if (this.store == null) {
        this.store = new this.UserDb();
      }
      return this.store.sql(cmd).exec(cb);
    };

    Postgresql.prototype.logError = function(err) {
      var info;
      if (err.position) {
        info = errorToLineCol(script, err);
        console.error("" + (Path.basename(filename)) + " [" + info.line + ", " + info.column + "] " + info.message + "\n");
        return cb(err);
      }
    };

    Postgresql.prototype.execFileCLI = function(filename, cb) {
      var args, command, host, port;
      port = this.config.port || 5432;
      host = this.config.host || "localhost";
      command = "psql";
      args = ["-U", this.config.user, "-q", "-d", this.config.database, "-h", host, "-p", port, "--file=" + filename, "-1", "--set", "ON_ERROR_STOP=1"];
      return Utils.spawn(command, args, {
        cwd: Path.dirname(filename),
        env_add: {
          PGPASSWORD: this.config.password
        }
      }, cb);
    };

    Postgresql.prototype.execFileDriver = function(filename, opts, cb) {
      var err, script, tx;
      tx = null;
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      try {
        script = Fs.readFileSync(filename, 'utf8');
      } catch (_error) {
        err = _error;
        return cb(err);
      }
      if (opts.notx) {
        return this.store.sql(script).exec(function(err, result) {
          if (err) {
            err = toSqlError(filename, err, script);
            console.error(err);
            return cb(1);
          }
          return cb();
        });
      } else {
        tx = this.store.transactable();
        tx.begin();
        return tx.sql(script).exec(function(err, result) {
          if (err) {
            err = toSqlError(filename, err, script);
            console.error(err);
            return tx.rollback(function() {
              return cb(1);
            });
          } else {
            return tx.commit(cb);
          }
        });
      }
    };

    Postgresql.prototype.console = function() {
      var args, command, host, port;
      port = this.config.port || 5432;
      host = this.config.host || "localhost";
      command = "psql";
      args = ["-U", this.config.user, "-d", this.config.database, "-h", host, "-p", port];
      return Utils.spawn(command, args, {
        stdio: 'inherit',
        env_add: {
          PGPASSWORD: this.config.password
        }
      }, function(code) {
        return process.exit(code);
      });
    };

    Postgresql.prototype.execFile = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.execFileDriver.apply(this, args);
    };

    Postgresql.prototype.init = function(cb) {
      var sql;
      sql = "create table if not exists schema_migrations (\n  version varchar(256) not null primary key,\n  up text,\n  down text,\n  created_at timestamp default current_timestamp\n);\n\ncreate table if not exists mygrate__sprocs (\n  name text primary key,\n  crc text not null,\n  created_at timestamp default current_timestamp\n);\n\nCREATE OR REPLACE FUNCTION mygrate__delfunc(_name text) returns void AS $$\nBEGIN\n    EXECUTE (\n       SELECT string_agg(format('DROP FUNCTION %s(%s);'\n                         ,oid::regproc\n                         ,pg_catalog.pg_get_function_identity_arguments(oid))\n              ,E'\n')\n       FROM   pg_proc\n       WHERE  proname = _name\n       AND    pg_function_is_visible(oid)\n    );\nexception when others then\n    -- do nothing, EXEC above returns an exception if it does not\n  -- find existing function\nEND $$ LANGUAGE plpgsql;\n";
      return this.exec(sql, cb);
    };

    Postgresql.prototype.registerSproc = function(info, cb) {
      var state, tx;
      state = {
        register: true,
        changed: false
      };
      tx = this.store.transactable();
      return Async.series({
        begin: (function(_this) {
          return function(cb) {
            return tx.begin(cb);
          };
        })(this),
        fnExists: (function(_this) {
          return function(cb) {
            var sql;
            sql = "SELECT name, crc\nFROM mygrate__sprocs\nWHERE name = $1";
            return _this.store.sql(sql, [info.name, info.crc]).one(function(err, row) {
              if (err) {
                return cb(err);
              }
              if (!row) {
                return cb();
              }
              if (row.crc === info.crc) {
                state.register = false;
                return cb();
              }
              state.changed = true;
              return _this.store.sql("SELECT mygrate__delfunc($1)", [info.name]).exec(cb);
            });
          };
        })(this),
        registerFn: (function(_this) {
          return function(cb) {
            var sql;
            if (!state.register) {
              return cb();
            }
            sql = "DELETE FROM mygrate__sprocs WHERE name = $1;\nINSERT INTO mygrate__sprocs (name, crc) VALUES ($1, $2);";
            return _this.store.sql(sql, [info.name, info.crc]).exec(function(err) {
              if (err) {
                return cb(err);
              }
              if (state.changed) {
                console.log("Updating sproc " + info.name);
              } else {
                console.log("Registering sproc " + info.name);
              }
              return _this.store.sql(info.body).exec(cb);
            });
          };
        })(this)
      }, function(err) {
        if (err) {
          return tx.rollback(function() {
            return cb(err);
          });
        }
        return tx.commit(cb);
      });
    };

    Postgresql.prototype.last = function(cb) {
      var sql;
      sql = "select *\nfrom schema_migrations\norder by version desc\nlimit 1;";
      return this.exec(sql, function(err, rows) {
        if (err) {
          return cb(err);
        }
        return cb(null, rows[0]);
      });
    };

    Postgresql.prototype.all = function(cb) {
      var sql;
      sql = "select *\nfrom schema_migrations\norder by version desc;";
      return this.exec(sql, function(err, rows) {
        var _ref;
        if ((err != null ? (_ref = err.message) != null ? _ref.indexOf('"schema_migrations" does not exist') : void 0 : void 0) > 0) {
          return cb(null, []);
        }
        if (err) {
          return cb(err);
        }
        return cb(null, rows);
      });
    };

    Postgresql.prototype.add = function(version, up, down, cb) {
      var sql;
      sql = "insert into schema_migrations(version, up, down)\nvalues($1, $2, $3)";
      return this.store.sql(sql, [version, up, down]).exec(cb);
    };

    Postgresql.prototype.remove = function(version, cb) {
      var sql;
      sql = "delete from schema_migrations\nwhere version = $1";
      return this.store.sql(sql, [version]).exec(cb);
    };

    Postgresql.prototype.promptSuperUser = function(defaultUser, cb) {
      var prompts;
      Prompt.delimiter = "";
      Prompt.start();
      prompts = [
        {
          name: 'user',
          description: 'root user',
          "default": defaultUser
        }, {
          name: 'password',
          hidden: true
        }
      ];
      return Prompt.get(prompts, cb);
    };

    Postgresql.prototype.argvSuperUser = function(argv, cb) {
      var _ref;
      return cb(null, {
        user: argv.user,
        password: (_ref = argv.password) != null ? _ref : ""
      });
    };

    Postgresql.prototype.createDatabase = function(defaultUser, argv) {
      var config, doCreate, self, using;
      self = this;
      config = this.config;
      using = this.using;
      doCreate = function(err, result) {
        var RootDb, execRootSql, host, password, port, rootConfig, statements, store, user;
        user = result.user, password = result.password, host = result.host, port = result.port;
        if (password.trim().length === 0) {
          password = null;
        }
        statements = ["select pg_terminate_backend(pid)\nfrom pg_stat_activity\nwhere datname='" + config.database + "'\n  and pid <> pg_backend_pid()", "drop database if exists " + config.database + ";", "drop user if exists " + config.user + ";", "create user " + config.user + " password '" + config.password + "' SUPERUSER CREATEROLE;", "create database " + config.database + " owner " + config.user + ";"];
        rootConfig = {
          user: user,
          password: password,
          host: config.host,
          port: config.port,
          database: "postgres"
        };
        RootDb = Postgres.define(rootConfig);
        store = new RootDb();
        execRootSql = function(sql, cb) {
          console.log('SQL', sql);
          return store.sql(sql).exec(cb);
        };
        return Async.forEachSeries(statements, execRootSql, function(err) {
          if (err) {
            console.error(err);
            console.error("Verify migrations/config.js has the correct host and port");
            return process.exit(1);
          } else {
            console.log("Created\n\tdatabase: " + config.database + "\n\tuser: " + config.user + "\n\tpassword: " + config.password + "\n\thost: " + config.host + "\n\tport: " + config.port);
            console.log("OK");
            return process.exit(0);
          }
        });
      };
      if (argv.user) {
        return this.argvSuperUser(argv, doCreate);
      } else {
        return this.promptSuperUser(defaultUser, doCreate);
      }
    };

    Postgresql.prototype.dropDatabase = function(defaultUser, argv) {
      var config, doDrop, self;
      self = this;
      config = this.config;
      doDrop = function(err, result) {
        var RootDb, execRootSql, host, password, port, rootConfig, statements, store, user;
        user = result.user, password = result.password, host = result.host, port = result.port;
        if (password.trim().length === 0) {
          password = null;
        }
        statements = ["drop database if exists " + config.database + ";", "drop user if exists " + config.user + ";"];
        rootConfig = {
          user: user,
          password: password,
          host: config.host,
          port: config.port,
          database: "postgres"
        };
        RootDb = Postgres.define(rootConfig);
        store = new RootDb();
        execRootSql = function(sql, cb) {
          return store.sql(sql).exec(cb);
        };
        return Async.forEachSeries(statements, execRootSql, function(err) {
          if (err) {
            console.error(err);
            return process.exit(1);
          } else {
            console.log("Dropped\n\tdatabase: " + config.database + "\n\tuser: " + config.user);
            console.log("OK");
            return process.exit(0);
          }
        });
      };
      if (argv.user) {
        return this.argvSuperUser(argv, doDrop);
      } else {
        return this.promptSuperUser(defaultUser, doDrop);
      }
    };

    return Postgresql;

  })();

  module.exports = Postgresql;

}).call(this);
